# Философия

Минутка занудства. Я долго сдерживался. Но в этом разделе, когда вся практическая информация предоставлена, дам волю своему зуду.

Если вам не очень интересен подобный формат повествования и вы привыкли думать прежде всего о деле, то можете смело заканчивать чтение. Все что могло случиться уже произошло.

## Ассоциация

Давайте еще раз взглянем на подход, который постоянно встречается в описании.

```csharp
class Cat
{
	public int Age { get; set; }
}

interface IAge
{
	int Age { get; set; }
}
  
[DtoContainer]
static class Dto
{
	class Cat_Dto : Cat, IAge { }
}
```

Класс Cat и интерфейс IAge ничего не знают друг о други. Они могут находится в разных библиотеках. Они могут разработываться разными командами для разных целей в противоположных уголках мира для разных проектов. Между ними может быть временная дистанция в десяток лет.

И вдруг неожиданно они стали родственными сущностями. Разработчик лишь подключил библиотеки с реализацией сущностей к своему проекту. Он написал **static class Dto** и случилось чудо.

Класс Cat_Dto, который позволил этому случиться ничего не реализует - он вырожденный. Класс Cat, сам того не ведая, всегда реализовывал IAge. Cat_Dto лишь явно определил эту связь за Cat: Cat_Dto **ассоциировал** Cat с IAge.

Другими словами, все что нужно для успешной ассоциации, кроме нескольких деталей уже существует в современном ООП языке программирования C#.

## Ассоциация, как часть компилятора языка

Как было сказано ранее, все инструменты библиотеки вращаются вокруг механизма **ассоциации**. На мой взгляд она достаточно просто могла бы стать частью языка. Например с помощью такой конструкции:

```csharp
interface IAge: partof Cat, partof Dog
{
	int Age { get; set; }
}
```
Это своебразный пример внешнего наследование интерфейса.

## AS и IS, как часть компилятора языка

Все типы C# точно знают всю иерархию своего наследования. Именно поэтому при применении операции implicit или explicit приведения типа, или в ответ на оператор AS, или в ответ на оператор IS программист получает ожидаемый результат.

Для поддержки работы **partof** логики необходимо помимо объекта исходного объекта проверять тип интерфейса к которому он приводится.

Описываемая библиотека реализует операцию AS через построенный адаптер в динамической сборки. Именно с этим связана необходимость определения интерфейсов для ассоциации в публичной области видимости - они должны быть доступны в динамической сборке.

## Копирование интерфейсов, как часть компилятора языка

На момент сборки кода в IL компилятор обладает полной информацией, для того, чтобы построить процедуру копирования интерфейса из одного объекта в другой на основе публичных свойств этого интерфейса.

Описываемая библиотека строит подобные процедуры копирования в динамической сборке
