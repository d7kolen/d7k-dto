# Философия

Минутка занудства. Я долго сдерживался. Но в этом разделе, когда вся практическая информация предоставлена, дам волю своему зуду.

Если вам не очень интересен подобный формат повествования и вы привыкли думать прежде всего о деле, то можете смело заканчивать чтение. Все что могло случиться уже произошло.

## Ассоциация

Давайте еще раз взглянем на подход, который постоянно встречается в описании.

```csharp
class Cat
{
	public int Age { get; set; }
}

interface IAge
{
	int Age { get; set; }
}
  
[DtoContainer]
static class Dto
{
	class Cat_Dto : Cat, IAge { }
}
```

Класс Cat и интерфейс IAge ничего не знают друг о друге. Они могут находиться в разных библиотеках. Они могут разработываться разными командами для разных целей в противоположных уголках мира для разных проектов. Между ними может быть временная дистанция в десяток лет.

И вдруг неожиданно они стали родственными сущностями. Разработчик лишь подключил библиотеки с реализацией сущностей к своему проекту. Он написал **static class Dto** и случилось чудо.

Класс Cat_Dto, который это позволил - вырожденный. Класс Cat, сам того не ведая, всегда реализовывал IAge. Cat_Dto лишь явно обозначил наличие этой связи: Cat_Dto **ассоциировал** Cat с IAge.

Посмотрите, все что нужно для успешной ассоциации, кроме нескольких деталей уже существует в современном ООП языке программирования C#.

## Ассоциация, как часть компилятора языка

Как было сказано ранее, все инструменты библиотеки вращаются вокруг механизма **ассоциации**. На мой взгляд она достаточно просто могла бы стать частью языка. Например с помощью такой конструкции:

```csharp
interface IAge_Dto: IAge
	partof Cat,
	partof Dog
{
	int Age { get; set; }
}
```

или без наследования от IAge

```csharp
interface IAge
	partof Cat,
	partof Dog
{
	int Age { get; set; }
}
```

Это своебразный пример внешнего наследования интерфейса отсутствующего в языке. Думаю, что такое "наследование" было бы полезено: оно бы облегчило бы определение родственость сущностей со внешними библиотеками. Местами бы избавило от копирования фрагментов внешних классов (дублирования кода).

## AS, как часть компилятора языка

Все типы C# точно знают всю иерархию своего наследования. Именно поэтому при применении операции implicit или explicit привидения типа, или в ответ на оператор AS, или в ответ на оператор IS программист получает ожидаемый результат.

Для поддержки работы **partof** логики необходимо помимо исходного объекта проверять тип интерфейса к которому он приводится.

Описываемая библиотека реализует операцию AS через построение адаптеров в динамической сборке. Именно с этим связана необходимость определения в публично области видимости интерфейсов для **ассоциации**. Об этом несколько раз сказано в описании.

## Копирование интерфейсов, как часть компилятора языка

На момент сборки кода IL компилятор обладает полной информацией, для того, чтобы построить процедуру копирования интерфейса из одного объекта в другой на основе свойств этого интерфейса.

Описываемая библиотека строит подобные процедуры копирования в динамической сборке.

Определение процедуры  копирования на этапе компиляции не сделает возможным полиморфное копирование всех общих интерфейсов двух объектов. Но сделает эту операцию более простой в реализации. Думаю, она была бы востребованной и сама по себе.

## Валидация интерфейса, как часть компилятора языка

Здесь у меня нет рецептов... "Полиморфная валидация", как и "полиморфным копированием" эта операция слишком магическая, что бы иметь шанс на реализацию в рамках компилятора языка. Более того, не уверен, что в этом действительно есть необходимость - эта логика может продолжать работать из библиотек.

## "Полиморфная" валидация и "полиморфное" копирование

Резануло слух?

Словом "полиморфное", я хотел сказать, что результат этих операций зависит от типа объектов над которым они осуществляются. Как и в случае с полиморфными операциями, их реальная реализация зависит от класса, чей полиморфный метод фактически вызывается (позднее связывание).

Полиморфизм, помоему, самое мощный инструмент объектно-ориентированных языков. Его проявления, обноруженные при работе с данной библиотекой и побудило меня ее опубликовать.
