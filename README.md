# d7k.Dto

Библиотека декларативного типизированного управления структурами данных

## Почему я ее использую:
1. Декларативные определения правил копирования, валидации и приведения типов
2. Типизированность. Ни какой магии - если два класса реализуют один интерфейс, то с ними можно делать все что допустимо для этого интерфейса (например, копировать поля одного в другой). Ни каких "возможно ты имел ввиду ...".
3. Классы структур данных (DTO) не обязаны напрямую реализовывать какие-либо интерфейсы. Прощай дилемма: "это внутренняя реализация - ей место в private зоне" vs "в public зоне реализовать проще".
4. Вы больше не обязаны впихивать, с недовольной гримасой на лице, интерфейсы внешних сервисов в свои классы, успакаивая себя низкой ценой данного решения.
5. Защита от ошибок именования полей в разных классах, в случае когда они значат одно и тоже. Так имя пользователя, всегда остается именем пользователя в независимости от того встречается оно в методе создания пользователя или форме клиентского заказа. Единожды выявленная абстракция будет побуждать разработчиков реиспользовать ее снова и снова, просто потому что так удобнее.
6. Хотите переименовывать поля сразу в нескольких класах одновременно? Разработчик должен оставаться спокоен даже тогда, когда "клиент" вдруг превращается в "пользователя", а "прибыль" в "сумму".
7. А как вам легкое реиспользование сложных правил валидации для ваших сущностей? Единожды определив правила, вы сможете переиспользовать их для новых классов, приложив минимум услилий.
8. А как вам гибкое комплексное копирование?

Если вы все еще здесь, то давайте рассмотрим базовые примеры использования библиотеки.
Постараюсь не углубляться в детали - все же это **Quickstart start guid**. Но если у кого возникнут вопросы, постараюсь расширить этот документ новыми разделами, комментариями и гиперссылками.

## [Копирование объектов](Doc/Copy.md)

```csharp
static void Main(string[] args)
{
	var dto = new DtoComplex().ByNestedClassesWithAttributes();
	
	var tCat = new Cat() { Age = 5 };
	var tDog = new Dog().CopyFrom(tCat, dto);
	//tDog.Age == 5
}

class Cat
{
	public int Age { get; set; }
}

class Dog
{
	public int Age { get; set; }
}

[DtoContainer]
static class Dto
{
	interface IAge
	{
		int Age { get; set; }
	}

	class Cat_Dto : Cat, IAge { }
	class Dog_Dto : Dog, IAge { }
}
```

[Интересно?](Doc/Copy.md)

## Копирование части объекта
????? Только root поля. Метов Update

## [Валидация](Doc/Validate.md)

```csharp
static void Main(string[] args)
{
	var dto = new DtoComplex().ByNestedClassesWithAttributes();

	var cat = new Cat() { Name = "  Snow  " };
	
	dto.FixValue(cat, nameof(cat), x => x.ValidateDto());
	//cat.Name == "Snow"
}

class Cat
{
	public string Name { get; set; }
}

[DtoContainer]
public static class Dto
{
	public interface IName
	{
		string Name { get; set; }
	}

	[DtoValidate]
	static void Validate(ValidationRuleFactory<IName> t)
	{
		t.RuleFor(x => x.Name).Trim();
	}

	class Cat_Dto : Cat, IName { }
}
```

[Интересно?](Doc/Validate.md)

### [Функции валидации](Doc/ValidateFunctions.md)

## [AS и IS](Doc/As_Is.md)

Внешнее наследование или extension inheritance
Внешний полиморфизм или extension polymorphism
