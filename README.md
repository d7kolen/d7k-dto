# d7k.Dto

Библиотека декларативного типизированного управления структурами данных

## Почему я ее использую:
1. Декларативные определения правил копирования, валидации и приведения типов
2. Типизированность. Ни какой магии - если два класса реализуют один интерфейс, то с ними можно делать все что допустимо для этого интерфейса (например, копировать поля одного в другой). Ни каких "возможно ты имел ввиду ...".
3. Классы структур данных (DTO) не обязаны напрямую реализовывать какие-либо интерфейсы. Прощай дилемма: "это внутренняя реализация - ей место в private зоне" vs "в public зоне реализовать проще".
4. Вы больше не обязаны впихивать, с недовольной гримасой на лице, интерфейсы внешних сервисов в свои классы, успакаивая себя низкой ценой данного решения.
5. Защита от ошибок именования полей в разных классах, в случае когда они значат одно и тоже. Так имя пользователя, всегда остается именем пользователя в независимости от того встречается оно в методе создания пользователя или форме клиентского заказа. Единожды выявленная абстракция будет побуждать разработчиков реиспользовать ее снова и снова, просто потому что так удобнее.
6. Хотите переименовывать поля сразу в нескольких класах одновременно? Разработчик должен оставаться спокоен даже тогда, когда "клиент" вдруг превращается в "пользователя", а "прибыль" в "сумму".
7. А как вам легкое реиспользование сложных правил валидации для ваших сущностей? Единожды определив правила, вы сможете переиспользовать их для новых классов, приложив минимум услилий.
8. А как вам гибкое комплексное копирование?

Если вы все еще здесь, то давайте рассмотрим базовые примеры использования библиотеки.
Постараюсь не углубляться в детали - все же это **Quickstart start guid**. Но если у кого возникнут вопросы, постараюсь расширить этот документ новыми разделами, комментариями и гиперссылками.

## [Копирование объектов](Doc/CopyStructures.md)

## Копирование части объекта
????? Только root поля. Метов Update

## [Валидация](Doc/Validate.md)

Все данные, приходящие от клиентов, необходимо проверять. **d7k.Dto** предоставляет такую возможность

```csharp
static void Main(string[] args)
{
	var tCat = new Cat() { Name = " Snow " };
	var validator = new ValidationRepository();
	tCat = validator.FixValue(tCat, nameof(tCat), x => x.NotEmpty().ValidateDto());
}

class Cat
{
	public string Name { get; set; }
}

[DtoContainer]
public static class Dto
{
	[DtoValidate]
	static void Validate(ValidationRuleFactory<Cat> t)
	{
		t.RuleFor(x => x.Name).Trim().NotEmpty();
	}
}
```

**ValidateDto** это еще один метод расширения в нашем DtoComplexHelper:

```csharp
public static class DtoComplexHelper
{
...
	public static PathValidation<TSrc, TProperty> ValidateDto<TSrc, TProperty>(this PathValidation<TSrc, TProperty> validation)
	{
		return validation.ValidateDto(m_dto);
	}
}
```

Механизм валидации может не только проверить корректность присланных данных, но и скорректировать какие-то простые случае. В нашем примере - убрать пустые символы в начале и в конце строки.

В качестве валидируемой сущности может выступать интерфейс. Поэтому, классы могут быть разделены на интерфейсы и валидация может производиться для каждого интерфейса в отдельности. Другие классы для которых определен этот интерфейс автоматически будут иметь эти валидаторы

## Стандартизация пустых значений

Для каждой структуры существует свой ответ, что такое "пустое значение" в том или ином ее поле: null, string.Empty, пустой массив или кастомный NullObject. В одном месте удобен один подход, в другом то же самое решение приводит к странным последствиям. Например к такому: **if (obj.A is MyNullObject) ...**.

Решение и стандартизация данного вопроса на ранних этапах исполнения запросов исключит появление ненужных **if** конструкиций в дальнейшем, сделав код более ориентированным на решение бизнес задач, а не "проблем" языка (в нашем случае C#).

К сожалению, заставить клиента всегда следовать заданным требованиям - задача противоричивая и приводит к конфликтам внутри команды:
- Почему я должен в поле A передавать пустой массив, а в поле B null?
- Ну ... моя ORM будет трактовать это значение ...

**ORM**? Серьезно? Какое дело клиенту до твоей ORM? У него есть 50 аналогичных арументов сделать иначе.

**d7k.Dto** считает, что клиент может следовать любому, удобному для него, подходу. Во время валидации входных значений сервер легко сможет привести все в "правильный" для него вид. Счастливы **клиент** и **ORM** одновременно.

## Валидация вложенных структур
## Валидация массивов и списков
## Вложенная комплексная валидация

## [Функции валидации](Doc/ValidateFunctions.md)

## Кастомная валидация и ValidationRule
## DtoAdapter
## DtoObject
